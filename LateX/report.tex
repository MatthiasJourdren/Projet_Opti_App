\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{titlesec}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{pgf-umlcd}
\usepackage[ruled,vlined]{algorithm2e} 
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}

\usetikzlibrary{positioning}
\geometry{margin=2.5cm}

% --- Styles visuels ---
\definecolor{cvblue}{HTML}{2A4D69}
\definecolor{cvgray}{HTML}{F5F5F5}

\titleformat{\section}{\normalfont\LARGE\bfseries\color{cvblue}}{}{0pt}{}
\titleformat{\subsection}{\normalfont\Large\bfseries\color{cvblue}}{}{0pt}{}
\setstretch{1.15}

\begin{document}

% ==============================
% PAGE DE GARDE
% ==============================

\begin{titlepage}
\centering
\vspace*{3cm}

{\Huge\textbf{Projet d'Optimisation}}\\[0.3cm]
{\Large\textbf{Le Problème du Voyageur de Commerce (TSP)}}\\[1cm]

\rule{0.6\textwidth}{1pt}\\[0.5cm]
{\LARGE\textbf{Rapport Final}}\\[0.3cm]
{\Large\textbf{Implémentation et Analyse d'Algorithmes}}\\
\rule{0.6\textwidth}{1pt}\\[3cm]

{\large\textbf{Master MIASHS — IMA-UCO (2025–2026)}}\\[1cm]
{\large\textbf{Auteurs :} Matthias Jourdren / Maxence Cornu Basset / Gaëtan Pezas}\\[0.3cm]
{\large\textbf{Date :} \today}

\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Introduction et Énoncé du Problème}
Le Problème du Voyageur de Commerce (\textbf{Traveling Salesperson Problem - TSP}) est l'un des problèmes d'optimisation combinatoire les plus célèbres. 

L'objectif est de trouver le chemin le plus court qui visite chaque ville exactement une fois et revient au point de départ. Mathématiquement, cela revient à chercher un \textbf{cycle hamiltonien de poids minimum} dans un graphe complet pondéré $G = (V, E)$. Le TSP est classé comme \textbf{NP-difficile}.

Nous avons implémenté et comparé quatre approches différentes :
\begin{itemize}
    \item Une méthode exacte (Branch and Bound)
    \item Une heuristique constructive (Plus proche voisin)
    \item Une heuristique de recherche locale (2-opt)
    \item Une heuristique de recherche locale (2-opt)
    \item Une méta-heuristique (GRASP\_LS)
\end{itemize}

\section{Méthodes Implémentées}

\subsection{Algorithme Exact : Branch and Bound}
L'algorithme de séparation et évaluation (Branch and Bound) explore l'arbre des solutions possibles tout en utilisant des bornes pour couper les branches inutiles.

\textbf{Complexité :} $O(n!)$ dans le pire des cas.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\KwData{current\_path, current\_cost}
\If{current\_cost $\ge$ best\_cost}{
    Return (Pruning)\;
}
\If{length(current\_path) == N}{
    total\_cost $\leftarrow$ current\_cost + distance(last, start)\;
    \If{total\_cost < best\_cost}{
        best\_cost $\leftarrow$ total\_cost\;
        best\_tour $\leftarrow$ copy(current\_path)\;
    }
    Return\;
}
\ForEach{unvisited next city $v$}{
    Mark $v$ as visited\;
    BranchAndBound(current\_path + $v$, current\_cost + distance(last, $v$))\;
    Mark $v$ as unvisited\;
}
\caption{Branch and Bound Pseudocode}
\end{algorithm}

\subsection{Heuristique Constructive : Plus Proche Voisin}
Cette approche gloutonne construit une solution en choisissant toujours la ville non visitée la plus proche.

\textbf{Complexité :} $O(n^2)$.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
Choisir start\_city (eg: 0)\;
current\_city $\leftarrow$ start\_city\;
Mark current\_city as visited\;
\While{there are unvisited cities}{
    Find unvisited next\_city closest to current\_city\;
    Add next\_city to path\;
    total\_cost $\leftarrow$ total\_cost + distance(current\_city, next\_city)\;
    current\_city $\leftarrow$ next\_city\;
}
total\_cost $\leftarrow$ total\_cost + distance(current\_city, start\_city)\;
\caption{Nearest Neighbor Pseudocode}
\end{algorithm}

\subsection{Recherche Locale : 2-opt}
L'algorithme 2-opt améliore une solution existante en inversant des segments du tour pour éliminer les croisements d'arêtes.

\textbf{Complexité :} $O(n^2)$ par itération.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
improvement $\leftarrow$ True\;
\While{improvement}{
    improvement $\leftarrow$ False\;
    \For{i from 1 to N-2}{
        \For{k from i+1 to N-1}{
            new\_tour $\leftarrow$ ReverseSegment(initial\_tour, i, k)\;
            \If{cost(new\_tour) < cost(initial\_tour)}{
                initial\_tour $\leftarrow$ new\_tour\;
                improvement $\leftarrow$ True\;
                Exit loops (First Improvement)\;
            }
        }
    }
}
\caption{2-opt Local Search Pseudocode}
\end{algorithm}

\newpage
\subsection{Méta-heuristique : GRASP\_LS}
La procédure GRASP\_LS (\textit{Greedy Randomized Adaptive Search Procedure}) combine construction aléatoire et recherche locale.

\textbf{Complexité :} $O(I \times (n^2 + \text{itérations\_2opt}))$, avec $I$ itérations.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\For{i from 1 to max\_iterations}{
    Solution $\leftarrow$ GreedyRandomizedConstruction(alpha)\;
    Solution $\leftarrow$ LocalSearch2Opt(Solution)\;
    \If{cost(Solution) < global\_best\_cost}{
        best\_Solution $\leftarrow$ Solution\;
    }
}
\caption{GRASP\_LS Pseudocode}
\end{algorithm}

\section{Expérimentations et Résultats}

Les tests ont été effectués sur des instances de taille 20 (données types \texttt{random} et \texttt{double\_circle}).

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Algorithme} & \textbf{Status} & \textbf{Temps (s)} & \textbf{Coût Relatif} & \textbf{Qualité} \\ \hline
Exact (B\&B) & Timeout & > 60.0 & - & Optimale \\ \hline
Plus Proche Voisin & Succès & ~0.03 & 100\% & Faible \\ \hline
Recherche Locale & Succès & ~0.03 & ~95\% & Moyenne \\ \hline
\textbf{GRASP\_LS} & Succès & ~0.12 & \textbf{~90\%} & \textbf{Excellente} \\ \hline
\end{tabular}
\caption{Comparaison des algorithmes sur des instances de 20 villes}
\end{table}

\subsection{Analyse}
\begin{enumerate}
    \item \textbf{Exact (B\&B)} : Souffre de l'explosion combinatoire. Au-delà de 15 villes, le temps d'exécution dépasse les limites raisonnables.
    \item \textbf{Plus Proche Voisin} : Très rapide mais les choix locaux mènent souvent à des détours coûteux en fin de parcours.
    \item \textbf{2-opt} : Indispensable pour raffiner les solutions et supprimer les intersections d'arêtes.
    \item \textbf{GRASP} : C'est la méthode la plus performante. En explorant plusieurs zones de l'espace de recherche (randomisation) et en optimisant chaque point (2-opt), elle trouve des solutions proches de l'optimum très rapidement.
\end{enumerate}

\section{Conclusion}
L'heuristique retenue comme étant la plus efficace est \textbf{GRASP\_LS}. 
Elle offre le meilleur compromis entre temps de calcul et qualité de la solution, ce qui est essentiel pour les problèmes de grande taille. Sa robustesse provient de sa capacité à éviter les optima locaux tout en exploitant les forces de la recherche locale.

\end{document}
