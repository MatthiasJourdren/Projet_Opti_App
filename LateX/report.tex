\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{titlesec}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{pgf-umlcd}
\usepackage[ruled,vlined,french,onelanguage]{algorithm2e} 
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}

% --- Définitions globales des mots-clés Algorithme (Français) ---
\SetKw{KwSi}{Si}
\SetKw{KwAlors}{Alors}
\SetKw{KwSinon}{Sinon}
\SetKw{KwPour}{Pour}
\SetKw{KwPourChaque}{Pour chaque}
\SetKw{KwTantQue}{Tant que}
\SetKw{KwFaire}{Faire}
\SetKw{KwRetourner}{Retourner}
\SetKwData{Donnees}{Données}

\usetikzlibrary{positioning}
\geometry{margin=2.5cm}

% --- Styles visuels ---
\definecolor{cvblue}{HTML}{2A4D69}
\definecolor{cvgray}{HTML}{F5F5F5}

\titleformat{\section}{\normalfont\LARGE\bfseries\color{cvblue}}{}{0pt}{}
\titleformat{\subsection}{\normalfont\Large\bfseries\color{cvblue}}{}{0pt}{}
\setstretch{1.15}

\begin{document}

% ==============================
% PAGE DE GARDE
% ==============================

\begin{titlepage}
\centering
\vspace*{3cm}

{\Huge\textbf{Projet d'Optimisation}}\\[0.3cm]
{\Large\textbf{Le Problème du Voyageur de Commerce (TSP)}}\\[1cm]

\rule{0.6\textwidth}{1pt}\\[0.5cm]
{\LARGE\textbf{Rapport Final}}\\[0.3cm]
{\Large\textbf{Implémentation et Analyse d'Algorithmes}}\\
\rule{0.6\textwidth}{1pt}\\[3cm]

{\large\textbf{Master MIASHS — IMA-UCO (2025–2026)}}\\[1cm]
{\large\textbf{Auteurs :} Matthias Jourdren / Maxence Cornu Basset / Gaëtan Pezas}\\[0.3cm]
{\large\textbf{Date :} \today}

\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Introduction et Énoncé du Problème}
Le Problème du Voyageur de Commerce (\textbf{Traveling Salesperson Problem - TSP}) est l'un des problèmes d'optimisation combinatoire les plus célèbres. 

L'objectif est de trouver le chemin le plus court qui visite chaque ville exactement une fois et revient au point de départ. Mathématiquement, cela revient à chercher un \textbf{cycle hamiltonien de poids minimum} dans un graphe complet pondéré $G = (V, E)$. Le TSP est classé comme \textbf{NP-difficile}.

Nous avons implémenté et comparé quatre approches différentes :
\begin{itemize}
    \item Une méthode exacte (Branch and Bound)
    \item Une heuristique constructive (Plus proche voisin)
    \item Une heuristique de recherche locale (2-opt)
    \item Une heuristique de recherche locale (2-opt)
    \item Une méta-heuristique (GRASP\_LS)
\end{itemize}

\section{Méthodes Implémentées}

\subsection{Algorithme Exact : Branch and Bound}
L'algorithme "Branch and Bound" est une méthode qui cherche la meilleure solution en explorant toutes les possibilités, comme dans un arbre. Pour gagner du temps, on utilise une astuce : si un début de chemin est déjà trop long par rapport au meilleur chemin complet que l'on connait, on arrête tout de suite d'explorer cette direction. On appelle cela "l'élagage". 
Pour notre problème de voyageur, cela nous permet de trouver le chemin le plus court possible (optimal) sans avoir besoin de tester tous les chemins un par un, ce qui serait impossible car il y en a trop.

\textbf{Complexité :} $O(n!)$.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon

\KwData{chemin\_actuel (liste des villes déjà visitées), cout\_actuel (longueur du chemin)}

\tcp{Condition d'arrêt (Élagage) : si on dépasse déjà le meilleur score connu}
\KwSi{cout\_actuel $\ge$ meilleur\_cout\_trouve}{
    \KwRetourner (On arrête cette branche, inutile de continuer)\;
}

\tcp{Si on a visité toutes les villes (feuille de l'arbre)}
\KwSi{longueur(chemin\_actuel) == Nombre\_Total\_Villes}{
    \tcp{On ajoute le retour au point de départ}
    cout\_total $\leftarrow$ cout\_actuel + distance(derniere\_ville, ville\_depart)\;
    
    \tcp{Est-ce que c'est un nouveau record ?}
    \KwSi{cout\_total < meilleur\_cout\_trouve}{
        meilleur\_cout\_trouve $\leftarrow$ cout\_total\;
        meilleur\_tour $\leftarrow$ copier(chemin\_actuel)\;
    }
    \KwRetourner\;
}

\tcp{Exploration des villes suivantes}
\KwPourChaque{ville $v$ qui n'est PAS encore dans chemin\_actuel}{
    Marquer $v$ comme visitée\;
    \tcp{Appel récursif : on continue le chemin avec $v$}
    BranchAndBound(chemin\_actuel + $v$, cout\_actuel + distance(derniere, $v$))\;
    Marquer $v$ comme non visitée (pour permettre d'autres chemins)\;
}
\caption{Pseudo-code Branch and Bound (Détaillé)}
\end{algorithm}

\subsection{Heuristique Constructive : Plus Proche Voisin}
L'algorithme du Plus Proche Voisin est très intuitif : on part d'une ville et on va toujours vers la ville la plus proche qui n'a pas encore été visitée. C'est simple et rapide.
Pour notre problème, cette méthode permet d'obtenir très vite un premier trajet complet. Même si ce trajet n'est pas parfait (il peut être un peu long), il sert de base de départ.

\textbf{Complexité :} $O(n^2)$.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\SetKw{KwTantQue}{Tant que}
\SetKw{KwFaire}{Faire}

\tcp{Initialisation}
Choisir une ville de départ arbitraire (ex: ville 0)\;
ville\_actuelle $\leftarrow$ ville\_depart\;
Marquer ville\_actuelle comme "VISITÉE"\;
chemin $\leftarrow$ [ville\_actuelle]\;
cout\_total $\leftarrow$ 0\;

\tcp{Boucle principale : on visite tout le monde}
\KwTantQue{il reste des villes NON visitées}{
    \tcp{Recherche du voisin le plus proche}
    Trouver la ville $v$ non visitée qui a la plus petite distance avec ville\_actuelle\;
    
    \tcp{Mise à jour}
    Ajouter $v$ au chemin\;
    cout\_total $\leftarrow$ cout\_total + distance(ville\_actuelle, $v$)\;
    ville\_actuelle $\leftarrow$ $v$ (on se déplace)\;
    Marquer $v$ comme "VISITÉE"\;
}

\tcp{Ne pas oublier de revenir au point de départ !}
cout\_total $\leftarrow$ cout\_total + distance(ville\_actuelle, ville\_depart)\;
Ajouter ville\_depart à la fin du chemin\;

\caption{Pseudo-code Plus Proche Voisin (Détaillé)}
\end{algorithm}

\subsection{Recherche Locale : 2-opt}
Le 2-opt est une technique pour corriger les défauts d'un trajet existant. Dans notre cas (villes sur une carte 2D), si deux routes se croisent, le chemin est forcément plus long que si elles ne se croisent pas. 
Le 2-opt repère ces croisements et "démêle" le chemin en inversant une section du tour. En répétant cela jusqu'à ce qu'il n'y ait plus de croisements, on obtient un trajet beaucoup plus propre et court.

\textbf{Complexité :} $O(n^2)$.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\SetKw{KwPour}{Pour}
\SetKw{KwSi}{Si}
\SetKw{KwAlors}{Alors}
\SetKw{KwTantQue}{Tant que}
\tcp{On part d'un tour existant (même mauvais)}
amelioration\_trouvee $\leftarrow$ Vrai\;

\KwTantQue{amelioration\_trouvee est Vrai}{
    amelioration\_trouvee $\leftarrow$ Faux (on remet à faux pour ce tour)\;
    
    \tcp{On teste toutes les paires d'arêtes possibles (i et k)}
    \KwPour{i de 1 à N-2}{
        \KwPour{k de i+1 à N-1}{
            \tcp{On simule l'inversion du segment entre i et k}
            nouveau\_tour $\leftarrow$ InverserSegment(tour\_actuel, i, k)\;
            
            \tcp{Est-ce que ça a raccourci le trajet ?}
            \KwSi{cout(nouveau\_tour) < cout(tour\_actuel)}{
                tour\_actuel $\leftarrow$ nouveau\_tour (On valide le changement)\;
                amelioration\_trouvee $\leftarrow$ Vrai\;
                \tcp{On recommence la boucle principale pour revérifier}
                Sortir des boucles "Pour" et recommencer le "Tant que"\;
            }
        }
    }
}
\KwRetourner tour\_actuel\;
\caption{Pseudo-code Recherche Locale 2-opt (Détaillé)}
\end{algorithm}

\newpage
\subsection{Méta-heuristique : GRASP\_LS}
La méthode GRASP mélange hasard et optimisation pour trouver une solution excellente.
Si on cherche toujours le "meilleur" choix immédiat (comme le Plus Proche Voisin), on risque de se coincer dans une solution moyenne. 
GRASP construit une solution en choisissant parfois un ville un peu moins bonne au hasard, ce qui permet d'explorer des chemins différents. Ensuite, on applique le 2-opt pour améliorer ce chemin à fond. En répétant cela plusieurs fois, on a plus de chances de tomber sur le meilleur trajet possible.

\textbf{Complexité :} Dépend du nombre de fois qu'on répète l'algorithme.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\SetKw{KwPour}{Pour}
\SetKw{KwSi}{Si}
\SetKwData{Meilleur}{Global}

meilleur\_cout\_global $\leftarrow$ Infini\;
meilleure\_solution\_globale $\leftarrow$ Vide\;

\KwPour{iteration de 1 à Nombre\_Max\_Iterations}{
    \tcp{Étape 1 : Construction semi-aléatoire}
    \tcp{alpha = 0 (glouton pur) à 1 (totalement aléatoire)}
    Solution\_Candidate $\leftarrow$ ConstructionGloutonneAleatoire(alpha)\;
    
    \tcp{Étape 2 : Optimisation locale}
    Solution\_Optimisee $\leftarrow$ RechercheLocale2Opt(Solution\_Candidate)\;
    
    \tcp{Mise à jour du record}
    \KwSi{cout(Solution\_Optimisee) < meilleur\_cout\_global}{
        meilleur\_cout\_global $\leftarrow$ cout(Solution\_Optimisee)\;
        meilleure\_solution\_globale $\leftarrow$ Solution\_Optimisee\;
    }
}
\KwRetourner meilleure\_solution\_globale\;
\caption{Pseudo-code GRASP\_LS (Détaillé)}
\end{algorithm}

\section{Expérimentations et Résultats}

Les tests ont été effectués sur des instances de taille 20 (données types \texttt{random} et \texttt{double\_circle}).

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Algorithme} & \textbf{Status} & \textbf{Temps (s)} & \textbf{Coût Relatif} & \textbf{Qualité} \\ \hline
Exact (B\&B) & Timeout & > 60.0 & - & Optimale \\ \hline
Plus Proche Voisin & Succès & ~0.03 & 100\% & Faible \\ \hline
Recherche Locale & Succès & ~0.03 & ~95\% & Moyenne \\ \hline
\textbf{GRASP\_LS} & Succès & ~0.12 & \textbf{~90\%} & \textbf{Excellente} \\ \hline
\end{tabular}
\caption{Comparaison des algorithmes sur des instances de 20 villes}
\end{table}

\subsection{Analyse}
\begin{enumerate}
    \item \textbf{Exact (B\&B)} : Souffre de l'explosion combinatoire. Au-delà de 15 villes, le temps d'exécution dépasse les limites raisonnables.
    \item \textbf{Plus Proche Voisin} : Très rapide mais les choix locaux mènent souvent à des détours coûteux en fin de parcours.
    \item \textbf{2-opt} : Indispensable pour raffiner les solutions et supprimer les intersections d'arêtes.
    \item \textbf{GRASP} : C'est la méthode la plus performante. En explorant plusieurs zones de l'espace de recherche (randomisation) et en optimisant chaque point (2-opt), elle trouve des solutions proches de l'optimum très rapidement.
\end{enumerate}

\section{Conclusion}
L'heuristique retenue comme étant la plus efficace est \textbf{GRASP\_LS}. 
Elle offre le meilleur compromis entre temps de calcul et qualité de la solution, ce qui est essentiel pour les problèmes de grande taille. Sa robustesse provient de sa capacité à éviter les optima locaux tout en exploitant les forces de la recherche locale.

\end{document}
