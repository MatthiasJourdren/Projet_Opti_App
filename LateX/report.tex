\documentclass[12pt,a4paper]{article}

% ==============================
% PACKAGES
% ==============================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[ruled,vlined,french,onelanguage]{algorithm2e}

% ==============================
% MISE EN PAGE
% ==============================
\geometry{margin=2.5cm}
\setstretch{1.15}

\definecolor{cvblue}{HTML}{2A4D69}

\titleformat{\section}{\normalfont\LARGE\bfseries\color{cvblue}}{}{0pt}{}
\titleformat{\subsection}{\normalfont\Large\bfseries\color{cvblue}}{}{0pt}{}

% ==============================
% MOTS-CLÉS ALGORITHMES
% ==============================
\SetKw{KwSi}{Si}
\SetKw{KwAlors}{Alors}
\SetKw{KwSinon}{Sinon}
\SetKw{KwPour}{Pour}
\SetKw{KwPourChaque}{Pour chaque}
\SetKw{KwTantQue}{Tant que}
\SetKw{KwRetourner}{Retourner}
\SetKwData{Donnees}{Données}

\begin{document}

% ==============================
% PAGE DE GARDE
% ==============================
\begin{titlepage}
\centering
\vspace*{3cm}

{\Huge\textbf{Projet d’Optimisation}}\\[0.3cm]
{\Large\textbf{Problème du Voyageur de Commerce (TSP)}}\\[1cm]

\rule{0.6\textwidth}{1pt}\\[0.5cm]
{\LARGE\textbf{Rapport Final}}\\[0.3cm]
{\Large\textbf{Algorithmes Exactes et Heuristiques}}\\
\rule{0.6\textwidth}{1pt}\\[3cm]

{\large\textbf{Master MIASHS — IMA-UCO (2025–2026)}}\\[1cm]
{\large\textbf{Auteurs :} Matthias Jourdren / Maxence Cornu Basset / Gaëtan Pezas}\\[0.3cm]
{\large\textbf{Date :} \today}

\end{titlepage}

\newpage
\tableofcontents
\newpage

% ==============================
\section{Introduction}

Le Problème du Voyageur de Commerce (\textbf{Traveling Salesperson Problem – TSP}) est un problème classique d’optimisation combinatoire.  
Il consiste à déterminer la tournée de coût minimal permettant de visiter chaque ville exactement une fois et de revenir à la ville de départ.

Ce problème est connu pour sa difficulté algorithmique, car il appartient à la classe des problèmes \textbf{NP-difficiles}.  
Dans ce projet, plusieurs approches ont été implémentées afin de comparer leurs performances et leur qualité de solution.

% ==============================
\section{Méthodes Implémentées}

% =====================================================
\subsection{Heuristique constructive : Plus proche voisin}

Dans notre implémentation du TSP, nous avons adapté l’heuristique du plus proche voisin avec un graphe complet pondéré représentant les villes et leurs distances. La tournée est construite à partir d’une ville de départ fixée (la ville 0), en ajoutant à chaque étape une ville non encore visitée. Les distances sont directement lues dans la matrice d’adjacence fournie en entrée.

Les villes déjà visitées sont mémorisées afin de garantir que chaque sommet n’est visité qu’une seule fois. Une fois toutes les villes intégrées à la tournée, le coût du retour vers la ville de départ est ajouté afin d’obtenir un cycle hamiltonien valide. Cette méthode fournit rapidement une solution réalisable, qui sert également de solution initiale pour les méthodes plus avancées.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon

\Donnees{Matrice de distances $D$, nombre de villes $n$}
ville\_depart $\leftarrow 0$\;
tour $\leftarrow [ville\_depart]$\;
Marquer ville\_depart visitée\;
cout $\leftarrow 0$\;

\TantQue{toutes les villes ne sont pas visitées}{
    ville\_suivante $\leftarrow$ ville non visitée minimisant $D[v_{courant}, v]$\;
    Ajouter ville\_suivante à la tournée\;
    cout $\leftarrow$ cout + $D[v_{courant}, ville\_suivante]$\;
    Marquer ville\_suivante visitée\;
    $v_{courant} \leftarrow$ ville\_suivante\;
}

cout $\leftarrow$ cout + $D[v_{courant}, ville\_depart]$\;
\KwRetourner tour, cout\;

\caption{Pseudo-code de l’heuristique du plus proche voisin}
\end{algorithm}

\paragraph{Complexité}
À chaque itération, toutes les villes non visitées sont examinées.  
La complexité temporelle est donc :
\[
\mathcal{O}(n^2)
\]

% =====================================================
\subsection{Algorithme exact : Branch and Bound}

L’algorithme de Branch and Bound est adapté au TSP en explorant les permutations possibles des villes sous forme de chemins partiels construits récursivement à partir d’une ville de départ fixée. Chaque chemin partiel représente une tournée incomplète, dont le coût cumulé est calculé à partir des poids du graphe.

Une borne supérieure correspond au meilleur coût trouvé jusqu’à présent. Dès que le coût partiel d’un chemin dépasse cette borne, la branche correspondante est abandonnée, ce qui permet de réduire l’espace de recherche. Afin de rendre l’algorithme exploitable en pratique, une limite de temps est imposée, ce qui permet d’interrompre la recherche pour les instances trop grandes.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon

\Donnees{Matrice de distances $D$, nombre de villes $n$}
meilleur\_cout $\leftarrow +\infty$\;

\BlankLine
\textbf{Procédure BnB(chemin, cout)}\;
\Indp
\KwSi{cout $\ge$ meilleur\_cout}{
    \KwRetourner\;
}

\KwSi{longueur(chemin) = n}{
    cout\_total $\leftarrow$ cout + $D[dernier, premier]$\;
    \KwSi{cout\_total < meilleur\_cout}{
        meilleur\_cout $\leftarrow$ cout\_total\;
    }
    \KwRetourner\;
}

\PourChaque{ville non visitée $v$}{
    Marquer $v$ visitée\;
    BnB(chemin $\cup \{v\}$, cout + $D[dernier, v]$)\;
    Marquer $v$ non visitée\;
}
\Indm

\BlankLine
BnB([0], 0)\;

\caption{Pseudo-code Branch and Bound pour le TSP}
\end{algorithm}

\paragraph{Complexité}
Dans le pire cas, toutes les permutations sont explorées.  
La complexité est donc :
\[
\mathcal{O}(n!)
\]

% =====================================================
\subsection{Heuristique de recherche locale : 2-opt}

La recherche locale 2-opt est appliquée au TSP en partant d’une tournée initiale obtenue par l’heuristique constructive. La tournée est représentée comme une liste ordonnée de villes, et son coût est calculé à partir de la matrice de distances.

L’adaptation repose sur l’évaluation systématique de modifications locales de la tournée, consistant à inverser des segments du parcours. Lorsqu’une modification permet de réduire le coût total, elle est acceptée et devient la nouvelle solution courante. Le processus est répété jusqu’à ce qu’aucune amélioration ne soit possible, ce qui correspond à un optimum local pour le problème du TSP.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon

\Donnees{Tournée initiale $T$}
amelioration $\leftarrow$ Vrai\;

\TantQue{amelioration}{
    amelioration $\leftarrow$ Faux\;
    \Pour{$i = 1$ \KwTo $n-2$}{
        \Pour{$k = i+1$ \KwTo $n-1$}{
            $T' \leftarrow$ inversion du segment $[i,k]$ de $T$\;
            \KwSi{cout($T'$) < cout($T$)}{
                $T \leftarrow T'$\;
                amelioration $\leftarrow$ Vrai\;
                Sortir des boucles\;
            }
        }
    }
}

\KwRetourner $T$\;

\caption{Pseudo-code de la recherche locale 2-opt}
\end{algorithm}

\paragraph{Complexité}
Les échanges possibles sont en $\mathcal{O}(n^2)$.  
La complexité globale est donc :
\[
\mathcal{O}(n^2)
\]

% =====================================================
\subsection{Méta-heuristique : GRASP}

La méta-heuristique GRASP est adaptée au TSP en combinant une phase constructive randomisée et une phase de recherche locale. La phase constructive repose sur une version modifiée de l’heuristique du plus proche voisin, dans laquelle le choix de la prochaine ville est effectué aléatoirement à partir d’une liste restreinte de candidats, définie à partir des distances dans le graphe.

Le paramètre $\alpha$ permet de contrôler le compromis entre choix glouton et diversification. Chaque solution construite est ensuite améliorée à l’aide de la recherche locale 2-opt. Cette procédure est répétée sur un nombre fixé d’itérations, et la meilleure tournée obtenue est conservée comme solution finale pour le TSP.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon

\Donnees{Matrice de distances $D$, $\alpha$, nombre d’itérations $I_{max}$}
meilleure\_solution $\leftarrow \emptyset$\;
meilleur\_cout $\leftarrow +\infty$\;

\Pour{$i = 1$ \KwTo $I_{max}$}{
    $T \leftarrow$ ConstructionRandomisée($\alpha$)\;
    $T \leftarrow$ RechercheLocale2Opt($T$)\;
    \KwSi{cout($T$) < meilleur\_cout}{
        meilleur\_cout $\leftarrow$ cout($T$)\;
        meilleure\_solution $\leftarrow T$\;
    }
}

\KwRetourner meilleure\_solution\;

\caption{Pseudo-code de GRASP appliqué au TSP}
\end{algorithm}

\paragraph{Complexité}
Chaque itération a un coût en $\mathcal{O}(n^2)$.  
La complexité totale est donc :
\[
\mathcal{O}(I_{max} \times n^2)
\]

% ==============================
\section{Conclusion}

Ce travail met en évidence les compromis entre méthodes exactes et heuristiques pour le TSP.  
L’algorithme Branch and Bound garantit l’optimalité mais devient rapidement impraticable, tandis que les heuristiques et méta-heuristiques offrent des solutions de bonne qualité en temps raisonnable.

\end{document}
