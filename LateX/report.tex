\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{titlesec}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{pgf-umlcd}
\usepackage[ruled,vlined]{algorithm2e} 
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}

\usetikzlibrary{positioning}
\geometry{margin=2.5cm}

% --- Styles visuels ---
\definecolor{cvblue}{HTML}{2A4D69}
\definecolor{cvgray}{HTML}{F5F5F5}

\titleformat{\section}{\normalfont\LARGE\bfseries\color{cvblue}}{}{0pt}{}
\titleformat{\subsection}{\normalfont\Large\bfseries\color{cvblue}}{}{0pt}{}
\setstretch{1.15}

\begin{document}

% ==============================
% PAGE DE GARDE
% ==============================

\begin{titlepage}
\centering
\vspace*{3cm}

{\Huge\textbf{Projet d'Optimisation}}\\[0.3cm]
{\Large\textbf{Le Problème du Voyageur de Commerce (TSP)}}\\[1cm]

\rule{0.6\textwidth}{1pt}\\[0.5cm]
{\LARGE\textbf{Rapport Final}}\\[0.3cm]
{\Large\textbf{Implémentation et Analyse d'Algorithmes}}\\
\rule{0.6\textwidth}{1pt}\\[3cm]

{\large\textbf{Master MIASHS — IMA-UCO (2025–2026)}}\\[1cm]
{\large\textbf{Auteurs :} Matthias Jourdren / Maxence Cornu Basset / Vincent Beausoleil / Abdenbi Iabbadene / Maxime De Ferry}\\[0.3cm]
{\large\textbf{Date :} \today}

\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Introduction et Énoncé du Problème}
Le Problème du Voyageur de Commerce (\textbf{Traveling Salesperson Problem - TSP}) est l'un des problèmes d'optimisation combinatoire les plus célèbres. 

L'objectif est de trouver le chemin le plus court qui visite chaque ville exactement une fois et revient au point de départ. Mathématiquement, cela revient à chercher un \textbf{cycle hamiltonien de poids minimum} dans un graphe complet pondéré $G = (V, E)$. Le TSP est classé comme \textbf{NP-difficile}.

Nous avons implémenté et comparé quatre approches différentes :
\begin{itemize}
    \item Une méthode exacte (Branch and Bound)
    \item Une heuristique constructive (Plus proche voisin)
    \item Une heuristique de recherche locale (2-opt)
    \item Une méta-heuristique (GRASP)
\end{itemize}

\section{Méthodes Implémentées}

\subsection{Algorithme Exact : Branch and Bound}
L'algorithme de séparation et évaluation (Branch and Bound) explore l'arbre des solutions possibles tout en utilisant des bornes pour couper les branches inutiles.

\textbf{Complexité :} $O(n!)$ dans le pire des cas.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\KwData{chemin\_actuel, cout\_actuel}
\If{cout\_actuel $\ge$ meilleur\_cout}{
    Retourner (Élagage)\;
}
\If{longueur(chemin\_actuel) == N}{
    cout\_total $\leftarrow$ cout\_actuel + distance(dernier, depart)\;
    \If{cout\_total < meilleur\_cout}{
        meilleur\_cout $\leftarrow$ cout\_total\;
        meilleur\_tour $\leftarrow$ copie(chemin\_actuel)\;
    }
    Retourner\;
}
\ForEach{ville suivante $v$ non visitée}{
    Marquer $v$ comme visitée\;
    BranchAndBound(chemin\_actuel + $v$, cout\_actuel + distance(dernier, $v$))\;
    Marquer $v$ comme non visitée\;
}
\caption{Pseudo-code Branch and Bound}
\end{algorithm}

\subsection{Heuristique Constructive : Plus Proche Voisin}
Cette approche gloutonne construit une solution en choisissant toujours la ville non visitée la plus proche.

\textbf{Complexité :} $O(n^2)$.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
Choisir ville\_depart (ex: 0)\;
ville\_actuelle $\leftarrow$ ville\_depart\;
Marquer ville\_actuelle comme visitée\;
\While{il reste des villes non visitées}{
    Trouver ville\_suivante non visitée la plus proche de ville\_actuelle\;
    Ajouter ville\_suivante au chemin\;
    cout\_total $\leftarrow$ cout\_total + distance(ville\_actuelle, ville\_suivante)\;
    ville\_actuelle $\leftarrow$ ville\_suivante\;
}
cout\_total $\leftarrow$ cout\_total + distance(ville\_actuelle, ville\_depart)\;
\caption{Pseudo-code Plus Proche Voisin}
\end{algorithm}

\subsection{Recherche Locale : 2-opt}
L'algorithme 2-opt améliore une solution existante en inversant des segments du tour pour éliminer les croisements d'arêtes.

\textbf{Complexité :} $O(n^2)$ par itération.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
amélioration $\leftarrow$ Vrai\;
\While{amélioration}{
    amélioration $\leftarrow$ Faux\;
    \For{i de 1 à N-2}{
        \For{k de i+1 à N-1}{
            nouveau\_tour $\leftarrow$ InverserSegment(tour\_initial, i, k)\;
            \If{cout(nouveau\_tour) < cout(tour\_initial)}{
                tour\_initial $\leftarrow$ nouveau\_tour\;
                amélioration $\leftarrow$ Vrai\;
                Sortir des boucles de parcours (First Improvement)\;
            }
        }
    }
}
\caption{Pseudo-code Recherche Locale 2-opt}
\end{algorithm}

\newpage
\subsection{Méta-heuristique : GRASP}
La procédure GRASP (\textit{Greedy Randomized Adaptive Search Procedure}) combine construction aléatoire et recherche locale.

\textbf{Complexité :} $O(I \times (n^2 + \text{itérations\_2opt}))$, avec $I$ itérations.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\For{i de 1 à max\_itérations}{
    Solution $\leftarrow$ ConstructionAléatoireGourmande(alpha)\;
    Solution $\leftarrow$ RechercheLocale2Opt(Solution)\;
    \If{cout(Solution) < meilleur\_cout\_global}{
        meilleur\_Solution $\leftarrow$ Solution\;
    }
}
\caption{Pseudo-code GRASP}
\end{algorithm}

\section{Expérimentations et Résultats}

Les tests ont été effectués sur des instances de taille 20 (données types \texttt{random} et \texttt{double\_circle}).

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Algorithme} & \textbf{Status} & \textbf{Temps (s)} & \textbf{Coût Relatif} & \textbf{Qualité} \\ \hline
Exact (B\&B) & Timeout & > 60.0 & - & Optimale \\ \hline
Plus Proche Voisin & Succès & ~0.03 & 100\% & Faible \\ \hline
Recherche Locale & Succès & ~0.03 & ~95\% & Moyenne \\ \hline
\textbf{GRASP} & Succès & ~0.12 & \textbf{~90\%} & \textbf{Excellente} \\ \hline
\end{tabular}
\caption{Comparaison des algorithmes sur des instances de 20 villes}
\end{table}

\subsection{Analyse}
\begin{enumerate}
    \item \textbf{Exact (B\&B)} : Souffre de l'explosion combinatoire. Au-delà de 15 villes, le temps d'exécution dépasse les limites raisonnables.
    \item \textbf{Plus Proche Voisin} : Très rapide mais les choix locaux mènent souvent à des détours coûteux en fin de parcours.
    \item \textbf{2-opt} : Indispensable pour raffiner les solutions et supprimer les intersections d'arêtes.
    \item \textbf{GRASP} : C'est la méthode la plus performante. En explorant plusieurs zones de l'espace de recherche (randomisation) et en optimisant chaque point (2-opt), elle trouve des solutions proches de l'optimum très rapidement.
\end{enumerate}

\section{Conclusion}
L'heuristique retenue comme étant la plus efficace est \textbf{GRASP}. 
Elle offre le meilleur compromis entre temps de calcul et qualité de la solution, ce qui est essentiel pour les problèmes de grande taille. Sa robustesse provient de sa capacité à éviter les optima locaux tout en exploitant les forces de la recherche locale.

\end{document}
